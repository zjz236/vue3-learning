import{b as e}from"./app.2e904f8f.js";const d={},o=e('<h1 id="vue2-x和vue3-x响应式对比" tabindex="-1"><a class="header-anchor" href="#vue2-x和vue3-x响应式对比" aria-hidden="true">#</a> Vue2.x和Vue3.x响应式对比</h1><h2 id="vue2-x" tabindex="-1"><a class="header-anchor" href="#vue2-x" aria-hidden="true">#</a> Vue2.x</h2><p>Vue2.x使用的是<code>Object.defineProperty</code>：</p><ul><li><code>Object.defineProperty</code>只能劫持对象的属性，所以新增属性时，需要重新遍历对象的每个属性。</li><li><code>Object.defineProperty</code>对新增属性需要手动进行<code>Observe</code>，对其新增属性再使用<code>Object.defineProperty</code>进行劫持。也正是因为这个原因，使用Vue给data中的数组或对象新增属性时，需要使用vm.$set才能保证新增的属性也是响应式的。</li></ul><h2 id="vue3-x" tabindex="-1"><a class="header-anchor" href="#vue3-x" aria-hidden="true">#</a> Vue3.x</h2><p>Vue3.x使用的是<code>Proxy</code>和<code>Reflect</code>，直接代理整个对象。</p><ul><li><code>Proxy</code>支持13种拦戳操作，这是defneProperty所不具有的新标准。</li><li><code>Proxy</code>作为新标准，长远来看，JS引擎会继续优化Proxy，但<code>getter</code>和<code>setter</code>基本不会再有针对性优化。<code>Proxy</code>兼容性差目前并没有一个完整支持Prox所有拦戳方法的 <code>Polyfill</code>方案。</li></ul>',7);d.render=function(e,d){return o};export default d;
