<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>The process: Making Vue 3 | Vue3学习日记</title><meta name="description" content=""><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="modulepreload" href="/vue3-learning/assets/app.2e904f8f.js"><link rel="modulepreload" href="/vue3-learning/assets/index.html.7813e549.js"><link rel="modulepreload" href="/vue3-learning/assets/index.html.43ec439c.js">
    <link rel="stylesheet" href="/vue3-learning/assets/style.f7145dee.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a aria-current="page" href="/vue3-learning/" class="router-link-active router-link-exact-active"><!----><span class="site-name">Vue3学习日记</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><div class="sidebar-mask"></div><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><a aria-current="page" href="/vue3-learning/" class="router-link-active router-link-exact-active nav-link sidebar-heading sidebar-item active" aria-label="The process: Making Vue 3"><!--[--><!--]--> The process: Making Vue 3 <!--[--><!--]--></a><ul class=""><li><!--[--><a aria-current="page" href="/vue3-learning/#为什么要重写" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="为什么要重写"><!--[--><!--]--> 为什么要重写 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/vue3-learning/#初始原型设计阶段" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="初始原型设计阶段"><!--[--><!--]--> 初始原型设计阶段 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/vue3-learning/#更快更小" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="更快更小"><!--[--><!--]--> 更快更小 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/vue3-learning/#满足规模化需求" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="满足规模化需求"><!--[--><!--]--> 满足规模化需求 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/vue3-learning/#寻求平衡" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="寻求平衡"><!--[--><!--]--> 寻求平衡 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--[--><a href="/vue3-learning/difference" class="nav-link sidebar-heading sidebar-item" aria-label="Vue3.x和Vue2.x的区别"><!--[--><!--]--> Vue3.x和Vue2.x的区别 <!--[--><!--]--></a><!----><!--]--><!--[--><a href="/vue3-learning/compositionAPI" class="nav-link sidebar-heading sidebar-item" aria-label="Composition API"><!--[--><!--]--> Composition API <!--[--><!--]--></a><!----><!--]--><!--[--><a href="/vue3-learning/responsive" class="nav-link sidebar-heading sidebar-item" aria-label="Vue2.x和Vue3.x响应式对比"><!--[--><!--]--> Vue2.x和Vue3.x响应式对比 <!--[--><!--]--></a><!----><!--]--><!--[--><a href="/vue3-learning/teleport" class="nav-link sidebar-heading sidebar-item" aria-label="Teleport"><!--[--><!--]--> Teleport <!--[--><!--]--></a><!----><!--]--><!--[--><a href="/vue3-learning/other" class="nav-link sidebar-heading sidebar-item" aria-label="其他区别"><!--[--><!--]--> 其他区别 <!--[--><!--]--></a><!----><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="the-process-making-vue-3" tabindex="-1"><a class="header-anchor" href="#the-process-making-vue-3" aria-hidden="true">#</a> The process: Making Vue 3</h1><p>在过去的一年里，Vue 团队一直致力于 Vue.js 的下一个主要版本，我们希望在 2020 年上半年发布。（在撰写本文时，这项工作正在进行中。）新的想法Vue 的主要版本在 2018 年底成型，当时 Vue 2 的代码库大约有两年半的历史。在通用软件的生命周期中，这听起来可能并不长，但在此期间前端格局发生了巨大变化。</p><p>两个关键的考虑因素让我们选择了 Vue 的新主要版本（和重写）：首先，主流浏览器中新的 JavaScript 语言功能的普遍可用性。其次，随着时间的推移，当前代码库中的设计和架构问题已经暴露出来。</p><h2 id="为什么要重写" tabindex="-1"><a class="header-anchor" href="#为什么要重写" aria-hidden="true">#</a> 为什么要重写</h2><h4 id="利用新的语言功能" tabindex="-1"><a class="header-anchor" href="#利用新的语言功能" aria-hidden="true">#</a> 利用新的语言功能</h4><p>随着 ES2015 的标准化，JavaScript——正式名称为 ECMAScript，缩写为 ES——获得了重大改进，主流浏览器终于开始为这些新增功能提供不错的支持。其中一些特别为我们提供了极大改进 Vue 功能的机会。</p><p>其中最值得注意的是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>，它允许框架拦截对对象的操作。Vue 的一个核心特性是能够监听对用户定义状态所做的更改并被动地更新 DOM。Vue 2 通过用 getter 和 setter 替换状态对象上的属性来实现这种反应性。切换到 Proxy 将使我们能够消除 Vue 现有的限制，例如无法检测新的属性添加，并提供更好的性能。</p><p>但是，Proxy 是一种本地语言功能，无法在旧版浏览器中完全填充。为了利用它，我们知道我们必须调整框架的浏览器支持范围——一个重大的突破性变化，只能在新的主要版本中发布。</p><h4 id="解决架构问题" tabindex="-1"><a class="header-anchor" href="#解决架构问题" aria-hidden="true">#</a> 解决架构问题</h4><blockquote><p>修复当前代码库中的这些问题需要大量的、有风险的重构，这几乎等同于重写。</p></blockquote><p>在维护 Vue 2 的过程中，我们积累了许多由于现有架构的限制而难以解决的问题。例如，模板编译器的编写方式使得正确的源映射支持非常具有挑战性。此外，虽然 Vue 2 在技术上支持构建针对非 DOM 平台的更高级别的渲染器，但我们必须分叉代码库并复制大量代码才能实现这一点。修复当前代码库中的这些问题需要大量的、有风险的重构，这几乎相当于重写。</p><p>与此同时，我们以各种模块的内部结构和似乎不属于任何地方的浮动代码之间的隐式耦合形式积累了技术债务。这使得孤立地理解代码库的一部分变得更加困难，我们注意到贡献者很少有信心做出重要的更改。重写将使我们有机会在考虑到这些事情的情况下重新思考代码组织。</p><h2 id="初始原型设计阶段" tabindex="-1"><a class="header-anchor" href="#初始原型设计阶段" aria-hidden="true">#</a> 初始原型设计阶段</h2><p>我们于 2018 年底开始对 Vue 3 进行原型设计，初步目标是验证这些问题的解决方案。在这个阶段，我们主要专注于为进一步发展奠定坚实的基础。</p><h4 id="切换到打字稿" tabindex="-1"><a class="header-anchor" href="#切换到打字稿" aria-hidden="true">#</a> 切换到打字稿</h4><p>Vue 2 最初是用普通 ES 编写的。在原型设计阶段后不久，我们意识到类型系统对这种规模的项目非常有帮助。类型检查大大减少了在重构过程中引入意外错误的机会，并帮助贡献者更有信心进行重要的更改。我们采用了 Facebook 的 <a href="https://flow.org/" target="_blank" rel="noopener noreferrer">Flow 类型检查器，<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 因为它可以逐渐添加到现有的纯 ES 项目中。Flow 在一定程度上有所帮助，但我们并没有像我们希望的那样从中受益；特别是，不断的突破性变化让升级变得痛苦。与 TypeScript 与 Visual Studio Code 的深度集成相比，对集成开发环境的支持也不理想。</p><p>我们还注意到用户越来越多地同时使用 Vue 和 TypeScript。为了支持他们的用例，我们必须与使用不同类型系统的源代码分开编写和维护 TypeScript 声明。切换到 TypeScript 可以让我们自动生成声明文件，减轻维护负担。</p><h4 id="解耦内部包" tabindex="-1"><a class="header-anchor" href="#解耦内部包" aria-hidden="true">#</a> 解耦内部包</h4><p>我们还采用了 monorepo 设置，其中框架由内部包组成，每个包都有自己的 API、类型定义和测试。我们想让这些模块之间的依赖关系更加明确，让开发人员更容易阅读、理解和更改所有模块。这是我们努力降低项目贡献障碍并提高其长期可维护性的关键。</p><h4 id="设置-rfc-流程" tabindex="-1"><a class="header-anchor" href="#设置-rfc-流程" aria-hidden="true">#</a> 设置 RFC 流程</h4><p>到 2018 年底，我们有了一个带有新反应系统和虚拟 DOM 渲染器的工作原型。我们已经验证了我们想要进行的内部架构改进，但只有面向公众的 API 更改的粗略草稿。是时候把它们变成具体的设计了。</p><p>我们知道我们必须尽早并小心地做到这一点。Vue 的广泛使用意味着重大更改可能导致用户的巨额迁移成本和潜在的生态系统碎片化。为确保用户能够提供有关重大更改的反馈，我们 在 2019 年初采用了 <a href="https://github.com/vuejs/rfcs" target="_blank" rel="noopener noreferrer">RFC（征求意见）流程<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>。每个 RFC 都遵循一个模板，其中的部分侧重于动机、设计细节、权衡和采用策略。由于该过程是在 GitHub 存储库中进行的，提案作为拉取请求提交，讨论在评论中有机展开。</p><p>事实证明，RFC 流程非常有用，它作为一个思维框架迫使我们充分考虑潜在变更的所有方面，并允许我们的社区参与设计流程并提交经过深思熟虑的功能请求。</p><h2 id="更快更小" tabindex="-1"><a class="header-anchor" href="#更快更小" aria-hidden="true">#</a> 更快更小</h2><blockquote><p>性能对于前端框架至关重要。</p></blockquote><p>性能对于前端框架至关重要。尽管 Vue 2 拥有具有竞争力的性能，但重写提供了一个机会，可以通过试验新的渲染策略走得更远。</p><h4 id="克服虚拟dom的瓶颈" tabindex="-1"><a class="header-anchor" href="#克服虚拟dom的瓶颈" aria-hidden="true">#</a> 克服虚拟DOM的瓶颈</h4><p>Vue 有一个相当独特的渲染策略：它提供类似 HTML 的模板语法，但将模板编译为返回虚拟 DOM 树的渲染函数。该框架通过递归遍历两个虚拟 DOM 树并比较每个节点上的每个属性来确定要更新实际 DOM 的哪些部分。由于现代 JavaScript 引擎执行的高级优化，这种有点暴力的算法通常很快，但更新仍然涉及大量不必要的 CPU 工作。当您查看包含大量静态内容和只有少量动态绑定的模板时，效率低下尤为明显——整个虚拟 DOM 树仍然需要递归遍历以找出发生了什么变化。</p><p>幸运的是，模板编译步骤让我们有机会对模板进行静态分析并提取有关动态部分的信息。Vue 2 通过跳过静态子树在一定程度上做到了这一点，但由于编译器架构过于简单，更高级的优化难以实现。在 Vue 3 中，我们使用适当的 AST 转换管道重写了编译器，这允许我们以转换插件的形式组合编译时优化。</p><p>新架构到位后，我们希望找到一种渲染策略，以尽可能消除开销。一种选择是放弃虚拟 DOM 并直接生成命令式 DOM 操作，但这会消除直接编写虚拟 DOM 渲染函数的能力，我们发现这对高级用户和库作者非常有价值。另外，这将是一个巨大的突破性变化。</p><p>下一个最好的事情是摆脱不必要的虚拟 DOM 树遍历和属性比较，它们往往在更新期间具有最大的性能开销。为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时则获取提示并尽可能采用快速路径。这里有三个主要的优化：</p><p>首先，在树级别，我们注意到在没有动态改变节点结构的模板指令（例如，<code>v-if</code> 和 <code>v-for</code>）的情况下，节点结构保持完全静态 。如果我们将模板划分为由这些结构指令分隔的嵌套“块”，则每个块内的节点结构再次变得完全静态。当我们更新块内的节点时，我们不再需要递归遍历树——块内的动态绑定可以在平面数组中进行跟踪。这种优化通过将我们需要执行的树遍历量减少一个数量级来规避虚拟 DOM 的大部分开销。</p><p>其次，编译器会主动检测模板中的静态节点、子树甚至数据对象，并将它们提升到生成代码中的渲染函数之外。这避免了在每次渲染时重新创建这些对象，大大提高了内存使用率并降低了垃圾收集的频率。</p><p>第三，在元素级别，编译器还根据需要执行的更新类型为每个具有动态绑定的元素生成优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，指示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。</p><p><strong>CPU时间</strong></p><p>也就是说，执行 JavaScript 计算所花费的时间，不包括浏览器 DOM 操作。</p><p>结合起来，这些技术显着提高了我们的渲染更新基准，Vue 3 有时占用的<strong>CPU 时间</strong>不到 Vue 2 的十分之一 。</p><h4 id="最小化包大小" tabindex="-1"><a class="header-anchor" href="#最小化包大小" aria-hidden="true">#</a> 最小化包大小</h4><p>框架的大小也会影响其性能。这是 Web 应用程序的一个独特问题，因为资产需要即时下载，并且在浏览器解析必要的 JavaScript 之前，应用程序将无法交互。对于单页应用程序尤其如此。虽然 Vue 一直是相对轻量级的——Vue 2 的运行时大小在 gzip 压缩后约为 23 KB——但我们注意到了两个问题：</p><p>首先，并不是每个人都使用框架的所有功能。例如，从不使用转换功能的应用程序仍需支付转换相关代码的下载和解析成本。</p><p>其次，随着我们添加新功能，该框架不断增长。当我们考虑添加新功能的权衡时，这会给包大小带来不成比例的权重。因此，我们倾向于只包含大多数用户会使用的功能。</p><p>理想情况下，用户应该能够在构建时删除未使用的框架功能的代码（也称为“摇树”），并且只需为他们使用的内容付费。这也将使我们能够发布一部分用户认为有用的功能，而无需为其余用户增加有效载荷成本。</p><p>在 Vue 3 中，我们通过将大部分全局 API 和内部帮助器移至 ES 模块导出来实现这一点。这允许现代捆绑器静态分析模块依赖项并删除与未使用的导出相关的代码。模板编译器还会生成摇树友好的代码，如果该功能在模板中实际使用，则仅导入该功能的助手。</p><p>框架的某些部分永远不会被摇树，因为它们对于任何类型的应用程序都是必不可少的。我们将这些必不可少的部分的度量称为基线大小。Vue 3 的基线大小经过 gzip 压缩后大约为 10 KB — 尽管添加了许多新功能，但还不到 Vue 2 的一半。</p><h2 id="满足规模化需求" tabindex="-1"><a class="header-anchor" href="#满足规模化需求" aria-hidden="true">#</a> 满足规模化需求</h2><p>我们还希望提高 Vue 处理大型应用程序的能力。我们最初的 Vue 设计侧重于入门门槛低和学习曲线平缓。但是随着 Vue 被更广泛地采用，我们对包含数百个模块并由数十名开发人员随时间维护的项目的需求有了更多了解。对于这些类型的项目，像 TypeScript 这样的类型系统和干净地组织可重用代码的能力至关重要，而 Vue 2 在这些领域的支持并不理想。</p><p>在设计 Vue 3 的早期阶段，我们尝试通过为使用类创作组件提供内置支持来改进 TypeScript 集成。挑战在于，我们需要使类可用的许多语言功能（例如类字段和装饰器）仍然是提案，并且在正式成为 JavaScript 的一部分之前可能会发生变化。所涉及的复杂性和不确定性让我们怀疑添加 Class API 是否真的合理，因为它除了提供稍微更好的 TypeScript 集成之外，没有提供任何其他东西。</p><p>我们决定研究其他方法来解决扩展问题。受 React Hooks 的启发，我们考虑公开较低级别的反应性和组件生命周期 API，以启用一种更自由形式的组件逻辑创作方式，称为 <a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener noreferrer">Composition API<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>。Composition API 不是通过指定一长串选项来定义组件，而是允许用户像编写函数一样自由地表达、组合和重用有状态的组件逻辑，同时提供出色的 TypeScript 支持。</p><p>我们对这个想法感到非常兴奋。尽管 Composition API 旨在解决特定类别的问题，但从技术上讲，仅在创作组件时才可以使用它。在提案的初稿中，我们有点超前并暗示我们可能会在未来的版本中用 Composition API 替换现有的 Options API。这导致了社区成员的大规模抵制，这给了我们一个宝贵的教训，即清楚地传达长期计划和意图，以及了解用户的需求。在听取了我们社区的反馈后，我们彻底修改了提案，明确表示 Composition API 将是 Options API 的补充和补充。修改后的提案得到了积极的响应，收到了很多建设性的建议。</p><h2 id="寻求平衡" tabindex="-1"><a class="header-anchor" href="#寻求平衡" aria-hidden="true">#</a> 寻求平衡</h2><blockquote><p>开发人员档案的多样性对应于用例的多样性。</p></blockquote><p>Vue 拥有超过 100 万开发人员的用户群，其中包括只有 HTML/CSS 基础知识的初学者、从 jQuery 转向的专业人士、从另一个框架迁移的老手、寻找前端解决方案的后端工程师以及处理大规模软件的软件架构师。开发人员配置文件的多样性对应于用例的多样性：一些开发人员可能希望在遗留应用程序上添加交互性，而另一些开发人员可能正在处理快速周转但维护问题有限的一次性项目；建筑师可能不得不在项目的整个生命周期内处理大型、多年的项目和波动的开发团队。</p><p>当我们寻求在各种权衡之间取得平衡时，Vue 的设计一直被这些需求所塑造和告知。Vue 的口号“渐进式框架”封装了由此过程产生的分层 API 设计。初学者可以通过 CDN 脚本、基于 HTML 的模板和直观的 Options API 享受流畅的学习曲线，而专家可以通过功能齐全的 CLI、渲染函数和 Composition API 处理雄心勃勃的用例。</p><p>要实现我们的愿景，还有很多工作要做——最重要的是，更新支持库、文档和工具以确保顺利迁移。在接下来的几个月里，我们将努力工作，我们迫不及待地想看看社区将使用 Vue 3 创建什么。</p><p>原文地址:The process: Making Vue 3(<a href="https://link.zhihu.com/?target=https%3A//increment.com/frontend/making-vue-3/" target="_blank" rel="noopener noreferrer">The process: Making Vue 3 – Increment: Frontend<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>)</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">7/23/2021, 6:37:09 PM</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: Zjz1236@">joe.zhu</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/vue3-learning/difference" class="nav-link" aria-label="Vue3.x和Vue2.x的区别"><!--[--><!--]--> Vue3.x和Vue2.x的区别 <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main></div><!----><!--]--></div>
    <script type="module" src="/vue3-learning/assets/app.2e904f8f.js" defer></script>
  </body>
</html>
